Great point. You're right to pause here â€” **the agent should be query-driven**, not file-driven.

Letâ€™s rebuild the full project outline for your **evidence-grounded agent system**, step by step, based on your real goals:

---

## ğŸ§  **Goal Recap**

Youâ€™re building a scientific chat agent that:

1. Accepts a user query.
2. Answers it by retrieving relevant text chunks (elastic).
3. Generates grounded subquestions and possibly deeper levels.
4. Builds a logical outline.
5. Writes sections based on those chunks.
6. Synthesizes a full article.

---

## âœ… Revised Project Architecture: Step-by-Step

---

### ### STEP 1: `POST /agent/query`

ğŸ“ **Main entry point**
This starts the flow: the user provides a query.

#### Input:

```json
{
  "query": "What is a black hole?"
}
```

#### What it does:

1. ğŸ” Searches **all indexed PDF chunks** in Elasticsearch (across all files)
2. ğŸ“¦ Collects \~100 most relevant chunks â†’ becomes the **working corpus**
3. ğŸ”§ Saves session state (query + top chunks)

#### Result:

Returns a session ID and some preview of retrieved content.

---

### ### STEP 2: `POST /agent/subquestions`

ğŸ” Follows from Step 1 â€” now we dig deeper.

#### Input:

```json
{
  "session_id": "abc123"
}
```

#### What it does:

1. ğŸ§  Takes top chunks from Step 1
2. ğŸ¤– Generates 5â€“10 **L1 subquestions**, using **only the retrieved chunks**
3. ğŸ“¦ Optionally, for each L1: generates L2 subquestions

#### Result:

Returns a tree of questions:

```json
{
  "What is a black hole?": [
    "What are the types of black holes?",
    "How are they detected?",
    ...
  ]
}
```

---

### ### STEP 3: `POST /agent/outline`

ğŸ§± Build the skeleton of the article.

#### Input:

```json
{
  "session_id": "abc123"
}
```

#### What it does:

1. ğŸ“š Uses the subquestions + top chunks
2. ğŸ“‘ Generates:

   * Title
   * Abstract
   * Section headings
   * Goals per section
   * Which questions go where

#### Result:

```json
{
  "outline": {
    "title": "...",
    "abstract": "...",
    "sections": [
      {
        "heading": "Formation of Black Holes",
        "goals": "...",
        "questions": [...]
      },
      ...
    ]
  }
}
```

---

### ### STEP 4: `POST /agent/section/{section_id}`

âœï¸ Writes the actual scientific content.

#### Input:

```json
{
  "session_id": "abc123",
  "section_id": "2"
}
```

#### What it does:

1. Retrieves all chunks relevant to this sectionâ€™s questions
2. Generates the full section text, based only on those chunks

---

### ### STEP 5: `POST /agent/article/finalize`

ğŸ§µ Final stitching and review.

#### Input:

```json
{ "session_id": "abc123" }
```

#### What it does:

* Combines all written sections
* Generates:

  * Introduction + transitions
  * Final polish
  * References (if stored)

---

## âœ… Summary: Routes and Responsibilities

| Endpoint                  | Purpose                    | Inputs                   | Outputs              |
| ------------------------- | -------------------------- | ------------------------ | -------------------- |
| `/agent/query`            | Start the research session | `{ query }`              | `session_id`, chunks |
| `/agent/subquestions`     | Generate subquestions      | `session_id`             | tree of subquestions |
| `/agent/outline`          | Build article structure    | `session_id`             | outline object       |
| `/agent/section/{id}`     | Write section              | `session_id`, section id | section text         |
| `/agent/article/finalize` | Merge + polish             | `session_id`             | full article         |

---

## ğŸ“ Suggested Folder Structure

```
backend/
â””â”€â”€ app/
    â”œâ”€â”€ routers/
    â”‚   â””â”€â”€ agent.py  â† All endpoints above
    â”œâ”€â”€ utils/
    â”‚   â””â”€â”€ agent/
    â”‚       â”œâ”€â”€ search_chunks.py
    â”‚       â”œâ”€â”€ subquestions.py
    â”‚       â”œâ”€â”€ outline.py
    â”‚       â”œâ”€â”€ writer.py
    â”‚       â””â”€â”€ memory.py  â† Tracks session state (in-memory or Redis)
```

---

## ğŸ”œ Next

Would you like to begin with:

1. Building `/agent/query` (start search + session)
2. Designing the `session_state` system (just a global dict for now?)
3. Testing the full flow locally via curl or Postman?

We can proceed step by step.
